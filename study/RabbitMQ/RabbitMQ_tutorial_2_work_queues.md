[原文链接](https://www.rabbitmq.com/tutorials/tutorial-two-spring-amqp.html)
# 工作队列
**前提**
这个教程假设你已经安装了RabbitMQ且运行在localhost标准端口5672.万一你使用不同端口.端口或认证，连接设置需要调整
**那里可以找到帮助呢**
如果你在学习教程过程中遇到问题，你们可以去通过邮件[联系](https://groups.google.com/forum/#!forum/rabbitmq-users)

![two](https://www.rabbitmq.com/img/tutorials/python-two.png)
在第一个教程中，我们写了程序去发送和接收消息从一个制定队列中。在这个章节我们会创建一个工作队列用来分配耗时的任务(每个任务都很耗时，每个任务分配给一个工作者)在多个工作者之间。
工作队列的主要思想是避免立刻去做和完成一个资源密集型任务（多个资源可能会有多个请求，比较耗时(一下子做不完)，前面已经有人在排队了，并不能立即处理。类似银行办业务，我们生产了复杂任务，它们排成一个队列，多个业务员帮我们处理，这种任务有些时候不能立刻给你执行，也不能立刻给你做完）。而是安排稍后做完成它们。我们把任务封装成消息发送到队列中。一个在后台运行的工作者进程会去除任务并最终执行它。当你运行多个工作者进程时，任务会被它们分享。
这中概念在网站应用中很有用(那些无法在一个网络请求窗口处理的复杂任务)。
## 准备
这份教程前一部分我们发送了一个消息包含"hello world".现在我们发送的字符代表复杂的任务。我们现实世界的任务。比如改变图片尺寸或者渲染PDF文档。所以我们伪造一个假装我们很忙-通过线程睡觉的方法。我们在字符串中妇孺了大量的...来让它看起来很复杂；每个点会一秒的工作量。比如说一个伪造的任务如**Hello...** 会消耗3秒。

## 代码部分省略,看上面原文链接，稍后如有需要，再补充

## 消息收到确认(也就是ack)
做一个任务可能需要几秒，你或许会好奇当一个消费者开始一个长任务且干到一般儿的时候死掉了会发生什么事情。
[官方文档](https://www.rabbitmq.com/confirms.html)（// TODO 有兴趣了，瞅瞅）
Spring AMQP 默认会采取保守措施来消息确认(看样子是重新排队)。如果一个监听器抛出一个异常，容器(我猜测是RabbitMQ)调用
  channel.basicReject(deliveryTag, requeue)
重新排队时默认设置，除非你明确设置：
  defaultRequeueRejected=false
(此处原文使用了or，我猜测此处是因果关系，上面设置了false，抛出了后面的异常)监听器抛出异常AmqpRejectAndDontRequeueException。这是典型的行为你想要从你的监听器获得的。再这种模式不用去担心忘记收到消息确认。处理完消息后，监听器会调用
  channel.basicAck()
消息收到确认必须和消息接收的的通道在同一个通道。尝试使用不同的通道确认会导致通道级别异常。可以参考[确认指导](https://www.rabbitmq.com/confirms.html)去学习更多。Spring AMQP一般注意这点除非我们组合使用代码和客户端组合使用，这是一些需要上心的。

忘记确认
(// TODO)

## 消息持久化
消息持久化是默认的。

## 公平调度 vs 循环调度
默认的。RabbitMQ 会发送每一个消息给下一个消费者，依次。平均下来没有给消费者会获得同样数量的消息。

  
