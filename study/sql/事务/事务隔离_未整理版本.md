# 事务四种隔离级别

    --事务指令
    --开始
    begin;
    -- 
    commit;
    --
    rollback;
    

    -- 测试数据
    DROP TABLE IF EXISTS `t1`;
    CREATE TABLE `t1`  (
      `s1` int(11) NOT NULL,
      `s2` char(5) CHARACTER SET latin1 COLLATE latin1_swedish_ci NOT NULL,
      PRIMARY KEY (`s1`) USING BTREE
    ) ENGINE = InnoDB CHARACTER SET = latin1 COLLATE = latin1_swedish_ci ROW_FORMAT = Dynamic;

    -- ----------------------------
    -- Records of t1
    -- ----------------------------
    INSERT INTO `t1` VALUES (1, 'a');
    INSERT INTO `t1` VALUES (2, 'b');

READ UNCOMMITTED(未提交读)
事务读取了其它事务未提交的修改。
会导致**脏读**
    -- 全局的
    set global transaction isolation level READ UNCOMMITTED;

    -- 当前会话
    set session transaction isolation level READ UNCOMMITTED;
    -- 查看InnoDB存储引擎 系统级的隔离级别 和 会话级的隔离级别
    select @@global.tx_isolation,@@tx_isolation;
事务A
    set session transaction isolation level READ UNCOMMITTED;
    begin;
事务B
    set session transaction isolation level READ UNCOMMITTED;
    begin;
    select * from t1 where s1=1;
事务A
    set session transaction isolation level READ UNCOMMITTED;
    begin;
    update t1 set s2='aa' where s1=1;

READ COMMITTED(提交读)
事务多次读取记录期间被其它事务提交修改
会导致**不可重复读**
解决方式:可以通过加记录锁来控制，如果事务A读取了记录期间，其它事务无法修改记录


REPEATABLE READ(可重复读)
解决了脏读和不可重复读
会导致**不可重复读**
解决方式:可以通过加记录锁来控制，如果事务A读取了记录期间，其它事务无法修改记录



事务隔离级别查询
select @@global.tx_isolation,@@tx_isolation;
事务隔离级别设置
set global transaction isolation level READ UNCOMMITTED;


